{
  "content": "\nI love Rust, and one of my favourite things about it is the way it pushes you to\nrethink loops and containers. Gone are the traditional `for` loops of C++ and\nPython, and in their place you get gloriously unreadable code like:\n\n```rust\nfn compact(filesystem: &[usize]) -> Vec<usize> {\n    let len = filesystem.iter().filter(not_space).count();\n    let mut rev_iter = filesystem.iter().rev().filter(not_space);\n    filesystem\n        .iter()\n        .scan(filesystem.iter().rev().filter(not_space), |rev_iter, x| {\n            if not_space(&x) {\n                Some(*x)\n            } else {\n                Some(*rev_iter.next().unwrap_or(&SPACE)) // unwrap should never fail\n            }\n        })\n        .take(len)\n        .enumerate()\n        .map(|(idx, val)| idx * val)\n        .sum()\n}\n```\n\nThat's something I wrote for [Day 9 of Advent of Code 2024](https://adventofcode.com/2024/day/9),\nand looking back at it, I have no idea what any of it is doing. All of those\nchained functions are collectively known as _iterator adaptors_, and they allow\nyou to perform transformations over collections of data. While I wouldn't\nrecommend writing anything like this in any production code, it's very useful to\nat least understand what each component is doing, as, when used appropriately,\niterator adaptors can lead to really expressive and performant code.\n\nHere I've sketched out a cheat-sheet for some of the most useful iterator\nadaptors and when you might want to use them. I may also return to this blog\npost and make edits in future if I come across any new tricks.\n\n## The Basics: `map`, `filter`, and Friends\n\n`map` is probably my most used adaptor, and it allows you to apply a transformation\nfunction over each element:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3];\nlet ys: Vec<usize> = xs.iter().map(|x: &usize| x + 1).collect();\n// Result: [2, 3, 4]\n```\n\nI've included type information here to help with clarity. Some things to note:\n\n- For a container filled with type `T`, `.iter()` creates an iterator over type `&T`.\n- `.collect()` writes the output of the iterator adaptor chain into a new container.\n  \nIf we don't need the contents of `xs` after this step, we could instead use\n`.into_iter()` to get an iterator directly over `T`. As this takes ownership of the\ncontents of `xs`, it will not be usable in any subsequent lines of code.\n\nThe second most common adaptor is `filter`, which returns elements from an iterator\nonly if some predicate is satisfied:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3];\nlet ys: Vec<&usize> = xs.iter().filter(|x: &&usize| *x % 2 == 0).collect();\n// Result: [&2]\n```\n\nAlready things are getting a little weird. Let's break that down:\n\n- The predicate function for `filter` takes the output of the previous adaptor\n  by reference, so rather than taking `&usize`, it instead takes `&&usize`.\n- We therefore need to dereference `x` inside the predicate function.\n- As `filter` passes on its inputs directly, the resulting type is still `&usize`,\n  not `usize` as we saw with `map`.\n\nA useful utility for converting `&T` to `T` is `.copied()`:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3];\nlet ys: Vec<usize> = xs.iter()\n                       .filter(|x: &&usize| *x % 2 == 0)\n                       .copied()\n                       .collect();\n// Result: [2]\n```\n\n`.cloned()` works similarly, and should be used when dealing with structs that\ncan be cloned but not copied.\n\nThere's also a special adaptor `filter_map` that combines both `map` and\n`filter`. The function it takes is one that returns a type `Option<T>`, \nand anything that evaluates to `None` is discarded:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3];\nlet ys: Vec<usize> = xs.iter()\n                       .filter_map(|x: &usize| {\n                           if x % 2 == 0 {\n                               Some(x * 2)\n                           } else {\n                               None\n                           }\n                        })\n                       .collect();\n// Result: [4]\n```\n\nAnything that evaluates to `Some(n)` to converted to `n`, while anything that\nevaluates to `None` is filtered out. The example above would perhaps be better\nwritten as separate `filter` and `map` calls, but `filter_map` can be really\nuseful whenever a mapping function returns an `Option` or `Result`. In the\nlatter case, the function `.ok()` can be used to convert the `Result` to an\noption:\n\n```rust\niter.filter_map(|x| return_result_type(x).ok())\n```\n\nThis can be much cleaner than the equivalent using plain `filter` and `map`:\n\n```rust\niter.map(|x| return_result_type(x))\n    .filter(|x| x.is_ok())\n    .map(|x| x.unwrap())\n```\n\nThe next useful adaptor we'll look at is `find`: a variant of `filter` that\nstops on finding the first element:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3];\nlet ys: &usize = xs.iter()\n                   .find(|x: &&usize| *x % 2 == 0)\n                   .unwrap();\n// Result: &2\n```\n\n`iter.find(f)` is equivalent to `iter.filter(f).next()`. There's also \n`iter.find_map(f)`, which is equivalent to `iter.filter_map(f).next()`.\n\nMoving on, the `take` function will continue with some iteration for a set\nnumber of steps:\n\n```rust\nlet sentence = \"The quick brown fox jumped over the lazy dog\";\nlet words: String = sentence\n    .split(' ')\n    .take(4)\n    .collect::<Vec<_>>()\n    .join(\" \");\n// Result: \"The quick brown fox\"\n```\n\nThe `.split(' ')` call here returns an iterator over each word, and\n`.take(4)` will stop after returning 4 values. We're then collecting\nthis into a `Vec` before using `.join(\" \")` to convert back to a String.\n\n`take_while` is very similar, except that it will continue while some\npredicate returns true:\n\n```rust\nlet sentence = \"The quick brown fox jumped over the lazy dog\";\nlet words: String = sentence\n    .split(' ')\n    .take_while(|s: &&str| !(*s).contains('z'))\n    .collect::<Vec<_>>()\n    .join(\" \");\n// Result: \"The quick brown fox jumped over the\"\n```\n\nSimilar to `filter_map`, `map_while` is a function that combines a `map`\nwith `take_while`, and will continue while the mapping function returns\n`Some(...)`:\n\n```rust\nlet sentence = \"The quick brown fox jumped over the lazy dog\";\nlet words: String = sentence\n    .split(' ')\n    .map_while(|s: &str| {\n        if s.contains('z') {\n            None\n        } else {\n            Some(s.to_uppercase())  \n        }\n    })\n    .collect::<Vec<_>>()\n    .join(\" \");\n// Result: \"THE QUICK BROWN FOX JUMPED OVER THE\"\n```\n\nFinally, the last basic adaptor we'll look at is `.rev()`, which allows you to\niterate over a container backwards:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3];\nlet ys: Vec<usize> = xs.iter().rev().copied().collect();\n// Result: [3, 2, 1]\n```\n\nNote that this is only implemented for types implementing `DoubleEndedIterator`,\nso while this should work fine when iterating over `Vec` or similar containers,\nit may not work for all data structures and certainly won't for iterators that\ngenerate data dynamically.\n\n## Chaining and Zipping\n\nA number of functions exist for combining iterators into longer iterators, or for\niterating over multiple data structures simultaneously. We'll start with `chain`,\nwhich allows you to stitch two iterators together:\n\n```rust\nlet xs: Vec<usize> = vec![0, 1, 2];\nlet ys: Vec<usize> = vec![3, 4, 5];\nlet zs: Vec<usize> = xs.iter()\n                        .chain(ys.iter())\n                        .copied()\n                        .collect();\n// Result: [0, 1, 2, 3, 4, 5]\n```\n\nThere is a performance penalty to using `chain`, so it should be used sparingly.\nA nice companion to `chain` is `once`, which creates an iterator over a single\nvalue:\n\n```rust\nuse std::iter::once;\nlet xs: Vec<usize> = vec![0, 1, 2];\nlet ys: Vec<usize> = xs.iter()\n                       .chain(once(&3))\n                       .copied()\n                       .collect();\n// Result: [0, 1, 2, 3]\n```\n\nIf you have an iterator over iterables, this can be reduced into a single\niteration using `flatten`:\n\n```rust\nlet xs: Vec<Vec<usize>> = vec![vec![0, 1], vec![2, 3]];\nlet ys: Vec<&usize> = xs.iter().flatten().collect();\n// Result: [0, 1, 2, 3]\n```\n\n`flat_map` is another `map` variant that can be handy for situations where\neach iteration creates new iterables:\n\n```rust\nlet xs: Vec<usize> = vec![0, 1, 2];\nlet ys: Vec<usize> = xs.iter()\n                       .flat_map(|x| {\n                           let y = 3 * x;\n                           [y, y + 1, y + 2]\n                       })\n                       .collect();\n// Result: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n```\n\nIf you want to iterate over two different containers at once, you can do so with\n`zip`:\n\n```rust\nlet xs: Vec<usize> = vec![0, 2, 4];\nlet ys: Vec<usize> = vec![1, 3, 5];\nlet zs: Vec<(&usize, &usize)> = xs.iter()\n                                  .zip(ys.iter())\n                                  .collect();\n// Result: [(&0, &1), (&2, &3), (&4, &5)]\n```\n\n`enumerate` is similar to `zip`, but the zipped iterator instead counts the\niteration count as it goes:\n\n```rust\nlet xs: Vec<usize> = vec![10, 11, 12];\nlet zs: Vec<(usize, &usize)> = xs.iter()\n                                 .enumerate()\n                                 .collect();\n// Result: [(0, &10), (1, &11), (2, &12)]\n```\n\nNote that the count is the _first_ element of the tuple, not the second as\nyou'll see in the equivalent Python function.\n\n## Reductions\n\nA number of adaptors exist to reduce the dimensionality of data:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3, 4, 5];\nlet min: Option<&usize> = xs.iter().min();  // Some(1)\nlet max: Option<&usize> = xs.iter().max();  // Some(5)\nlet sum: usize = xs.iter().sum();           // 15\nlet prod: usize = xs.iter().product();      // 120\nlet count: usize: xs.iter().count();        // 5\n```\n\nThe functions `min` and `max` return an `Option` type, and will return `None` if\nthe iterator is empty. `sum` and `product` instead start with an implicit first\nelement of `0` and `1` respectively.\n\nYou can also reduce boolean data:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3, 4, 5];\nlet any: bool = xs.iter().any(|&x| x > 3); // true\nlet all: bool = xs.iter().all(|&x| x > 3); // false\n```\n\nThese functions are short circuiting, meaning `any` will exit early as soon as\nit encounters a `true` outcome and `all` will exit early as soon as it\nencounters a `false` outcome. Note that this means `any` will return `false` on\nan empty iterator while `all` will return `true`.\n\nTo make a more general reduction we can use the functions `fold` and `reduce`.\nBoth are very similar, but `fold` requires the provision of an initial value,\nwhile `reduce` uses the first element:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3, 4, 5];\nlet fold: usize = xs.iter().fold(10, |acc, &x| acc + x)\n// Result: 25\nlet reduce: Option<usize> = xs.into_iter()\n                              .reduce(|acc, x| acc + 2 * x);\n// Result: Some(29), so the first element is not multiplied by 2!\n```\n\nSimilarly to `min` and `max`, `fold` returns `None` if the iterator is\nempty.\n\nFinally, we'll look at `scan`, which is similar to `fold` in that it maintains\nan internal state, but it returns another iterator instead of performing a\nreduction. This can used for things like cumulative products:\n\n```rust\nlet xs: Vec<usize> = vec![1, 2, 3, 4, 5];\nlet scan: Vec<usize> = xs.iter()\n                         .scan(1, |state, &x|{\n                             let result = *state * x;\n                             *state = result;\n                             Some(result)\n                         })\n                        .collect();\n// Result: [1, 2, 6, 24, 120]\n```\n\n## Peekable\n\nSometimes it's useful to know what's coming next in an iterator before committing\nto the next element. An example I ran into recently was accounting for different\nline ending characters while iterating through a string in a scenario where\n`string.lines()` wasn't appropriate:\n\n```rust\nlet paragraph = \"Foo\\nBar\\rBaz\\r\\n\";\nlet mut newlines = 0;\nlet mut it = paragraph.chars().peekable();\nwhile let Some(c) = it.next() {\n    match c {\n        '\\r' => {\n            // Handle CRLF\n            if let Some('\\n') = it.peek() {\n                continue;\n            }\n            // Handle CR\n            newlines += 1;\n        },\n        '\\n' => {\n            // Handle LF\n            newlines += 1;\n        },\n        _ => {\n            // Non-newline, do nothing!\n        }\n    }\n}\n// Result: newlines == 3\n```\n\nTo handle all three possible line ending types, we need to recognise `\\r\\n` as a\nsingle character. The method here peeks ahead on finding a `\\r` and does not advance\nthe iterator forward. On the next iteration, the `\\n` will be captured as usual and\nrecognised as a standard line ending.\n\nAs with the chaining methods earlier, there's a performance penalty to using peekable\niterators, so I recommend using them sparingly.\n\n## Advanced Topics\n\nThat just about covers all of the standard iterator tricks I'm aware of! For\nmore complicated iterator manipulation, I recommend checking out the\n[`itertools`](https://docs.rs/itertools/latest/itertools/index.html) crate. Some\nhighlights include:\n\n- `.tuple_windows()`, which allows you to iterate over a window:\n\n```rust\nuse itertools::Itertools;\nlet mut it = (0..5).tuple_windows::<(_, _, _)>();\nassert_eq!(Some((0, 1, 2)), it.next());\nassert_eq!(Some((1, 2, 3)), it.next());\nassert_eq!(Some((2, 3, 4)), it.next());\n```\n\n- `.permutations()`, which is similar to Python's `itertools.permutations()`:\n\n```rust\nuse itertools::Itertools;\nlet mut it = (0..3).permutations(2);\nassert_eq!(Some(vec![0, 1]), it.next());\nassert_eq!(Some(vec![0, 2]), it.next());\nassert_eq!(Some(vec![1, 0]), it.next());\nassert_eq!(Some(vec![1, 2]), it.next());\nassert_eq!(Some(vec![2, 0]), it.next());\nassert_eq!(Some(vec![2, 1]), it.next());\n```\n\n- `.unique()`, which filters elements that have already been encountered:\n\n```rust\nlet xs: Vec<usize> = vec![0, 1, 0, 2, 0, 3];\nlet ys: Vec<usize> = xs.into_iter().unique().collect();\n// Result: [0, 1, 2, 3]\n```\n\nAnother crate definitely worth checking out is\n[`rayon`](https://docs.rs/rayon/latest/rayon/), which provides parallel versions\nof most standard iterator adaptors:\n\n```rust\nuse rayon::prelude::*;\nlet xs: Vec<usize> = vec![0, 1, 2, 3, 4, 5, 6];\nlet ys: Vec<usize> = xs.into_par_iter()\n                       .map(|x| x + 1)\n                       .collect();\n// Result: [1, 2, 3, 4, 5, 6, 7]\n```\n\nTypically, the only difference is that `.par_iter()` is used in place of `.iter()`\nand `.into_par_iter()` is used in place of `.into_iter()`. The number of threads\nused can be chosen by setting the environment variable `RAYON_NUM_THREADS`.\n",
  "data": {
    "title": "Rust Iterator Adaptors",
    "subtitle": "Knowing your `find` from your `filter`",
    "published": "2025-06-16T00:00:00.000Z"
  },
  "isEmpty": false,
  "excerpt": ""
}
